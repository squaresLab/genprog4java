package clegoues.genprog4java.Search;

import java.util.ArrayList;

import clegoues.genprog4java.fitness.Fitness;
import clegoues.genprog4java.mut.EditOperation;
import clegoues.genprog4java.rep.JavaRepresentation;
import clegoues.genprog4java.rep.Representation;
import ylyu1.wean.VariantCheckerMain;

public class GeneticProgramming<G extends EditOperation> extends Search<G>{
	private int generationsRun = 0;
	public static int mode = 3;
	public GeneticProgramming(Fitness engine) {
		super(engine);
	}


	/*
	 * prepares for GA by registering available mutations (including templates
	 * if applicable) and reducing the search space, and then generates the
	 * initial population, using [incoming_pop] if non-empty, or by randomly
	 * mutating the [original]. The resulting population is evaluated for
	 * fitness before being returned. This may terminate early if a repair is
	 * found in the initial population (by [calculate_fitness]).
	 * 
	 * @param original original variant
	 * 
	 * @param incoming_pop possibly empty, incoming population
	 * 
	 * @return initial_population generated by mutating the original
	 */
	protected Population<G> initialize(Representation<G> original,
			Population<G> incomingPopulation) throws RepairFoundException, GiveUpException {
		original.getLocalization().reduceSearchSpace();

		Population<G> initialPopulation = incomingPopulation;

		if (incomingPopulation != null
				&& incomingPopulation.size() > incomingPopulation.getPopsize()) {
			initialPopulation = incomingPopulation.firstN(incomingPopulation
					.getPopsize());
		} 
		int stillNeed = initialPopulation.getPopsize()*2
				- initialPopulation.size();
		if (stillNeed > 0) {
			initialPopulation.add(original.copy());
			stillNeed--;
		}
		for (int i = 0; i < stillNeed; i++) {
			Representation<G> newItem = original.copy();
			this.mutate(newItem);
			initialPopulation.add(newItem);
		}

		for (Representation<G> item : initialPopulation) {
			if (fitnessEngine.testFitness(0, item)) {
				this.noteSuccess(item, original, 0);
				if(!continueSearch) {
					throw new RepairFoundException();
				}
			}
		}
		return initialPopulation;
	}

	/*
	 * runs the genetic algorithm for a certain number of iterations, given the
	 * most recent/previous generation as input. Returns the last generation,
	 * unless it is killed early by the search strategy/fitness evaluation. The
	 * optional parameters are set to the obvious defaults if omitted.
	 * 
	 * @param start_gen optional; generation to start on (defaults to 1)
	 * 
	 * @param num_gens optional; number of generations to run (defaults to
	 * [generations])
	 * 
	 * @param incoming_population population produced by the previous iteration
	 * 
	 * @raise Found_Repair if a repair is found
	 * 
	 * @raise Max_evals if the maximum fitness evaluation count is reached
	 * 
	 * @return population produced by this iteration *)
	 */
	protected void runAlgorithm(Representation<G> original, Population<G> initialPopulation) throws RepairFoundException, GiveUpException {
		/*
		 * the bulk of run_ga is performed by the recursive inner helper
		 * function, which Claire modeled off the MatLab code sent to her by the
		 * UNM team
		 */
		logger.info("search: genetic algorithm begins\n");

		
		
		// Step 0: run daikon
		if(mode>0)
		{
		System.out.println("Here we are");
		VariantCheckerMain.runDaikon();
		VariantCheckerMain.checkInvariantOrig();
		}
		
		
		assert (Search.generations >= 0);
		Population<G> incomingPopulation = this.initialize(original,
				initialPopulation);
		int gen = 1;
		int checked = 0;
		
		while (gen < Search.generations) {
			VariantCheckerMain.turn=gen;
			logger.info("search: generation" + gen);
			generationsRun++;
			assert (initialPopulation.getPopsize() > 0);
			
			
			if(mode>1||(mode==1&&gen==1))
			{
			//if(gen==1) {
			// Step 0.5: Check Invariant
			VariantCheckerMain.checkInvariant(incomingPopulation);//}
			}
			
			
			// Step 1: selection
			incomingPopulation.selection(incomingPopulation.getPopsize());
			
			for(Representation<G> item : incomingPopulation)
			{
				System.out.println(item.hashCode());
			}
			// step 2: crossover
			incomingPopulation.crossover(original);

			// step 3: mutation
			ArrayList<Representation<G>> newlist = new ArrayList<Representation<G>>();
			for (Representation<G> item : incomingPopulation) {
				
				Representation<G> newItem =item.copy();
				this.mutate(newItem);
				newlist.add(newItem);
			}
			incomingPopulation.getPopulation().addAll(newlist);

			// step 4: fitness
			for (Representation<G> item : incomingPopulation) {
				if (fitnessEngine.testFitness(gen, item)) {
					this.noteSuccess(item, original, gen);
					if(!continueSearch) 
						return;
				}
			}
			gen++;
		}
	}
}
